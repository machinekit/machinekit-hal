// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/types.proto

#ifndef PROTOBUF_machinetalk_2fprotobuf_2ftypes_2eproto__INCLUDED
#define PROTOBUF_machinetalk_2fprotobuf_2ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include "machinetalk/protobuf/nanopb.pb.h"
// @@protoc_insertion_point(includes)

namespace machinetalk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_machinetalk_2fprotobuf_2ftypes_2eproto();
void protobuf_AssignDesc_machinetalk_2fprotobuf_2ftypes_2eproto();
void protobuf_ShutdownFile_machinetalk_2fprotobuf_2ftypes_2eproto();


enum ValueType {
  HAL_BIT = 1,
  HAL_FLOAT = 2,
  HAL_S32 = 3,
  HAL_U32 = 4,
  HAL_S64 = 5,
  HAL_U64 = 6,
  STRING = 7,
  BYTES = 8,
  INT32 = 20,
  UINT32 = 30,
  INT64 = 40,
  UINT64 = 50,
  DOUBLE = 60,
  BOOL = 80,
  CARTESIAN = 100,
  LEGACY_CARTESIAN = 110,
  POSE = 120,
  LEGACY_POSE = 130
};
bool ValueType_IsValid(int value);
const ValueType ValueType_MIN = HAL_BIT;
const ValueType ValueType_MAX = LEGACY_POSE;
const int ValueType_ARRAYSIZE = ValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ValueType_descriptor();
inline const ::std::string& ValueType_Name(ValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ValueType_descriptor(), value);
}
inline bool ValueType_Parse(
    const ::std::string& name, ValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValueType>(
    ValueType_descriptor(), name, value);
}
enum HalPinDirection {
  HAL_IN = 16,
  HAL_OUT = 32,
  HAL_IO = 48
};
bool HalPinDirection_IsValid(int value);
const HalPinDirection HalPinDirection_MIN = HAL_IN;
const HalPinDirection HalPinDirection_MAX = HAL_IO;
const int HalPinDirection_ARRAYSIZE = HalPinDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* HalPinDirection_descriptor();
inline const ::std::string& HalPinDirection_Name(HalPinDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    HalPinDirection_descriptor(), value);
}
inline bool HalPinDirection_Parse(
    const ::std::string& name, HalPinDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HalPinDirection>(
    HalPinDirection_descriptor(), name, value);
}
enum HalParamDirection {
  HAL_RO = 64,
  HAL_RW = 192
};
bool HalParamDirection_IsValid(int value);
const HalParamDirection HalParamDirection_MIN = HAL_RO;
const HalParamDirection HalParamDirection_MAX = HAL_RW;
const int HalParamDirection_ARRAYSIZE = HalParamDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* HalParamDirection_descriptor();
inline const ::std::string& HalParamDirection_Name(HalParamDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    HalParamDirection_descriptor(), value);
}
inline bool HalParamDirection_Parse(
    const ::std::string& name, HalParamDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HalParamDirection>(
    HalParamDirection_descriptor(), name, value);
}
enum HalFunctType {
  FS_LEGACY_THREADFUNC = 0,
  FS_XTHREADFUNC = 1,
  FS_USERLAND = 2
};
bool HalFunctType_IsValid(int value);
const HalFunctType HalFunctType_MIN = FS_LEGACY_THREADFUNC;
const HalFunctType HalFunctType_MAX = FS_USERLAND;
const int HalFunctType_ARRAYSIZE = HalFunctType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HalFunctType_descriptor();
inline const ::std::string& HalFunctType_Name(HalFunctType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HalFunctType_descriptor(), value);
}
inline bool HalFunctType_Parse(
    const ::std::string& name, HalFunctType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HalFunctType>(
    HalFunctType_descriptor(), name, value);
}
enum ObjectType {
  HAL_OBJECT_INVALID = 0,
  HAL_PIN = 1,
  HAL_SIGNAL = 2,
  HAL_PARAM = 3,
  HAL_THREAD = 4,
  HAL_FUNCT = 5,
  HAL_COMPONENT = 6,
  HAL_VTABLE = 7,
  HAL_INST = 8,
  HAL_RING = 9,
  HAL_GROUP = 10,
  HAL_MEMBER = 11,
  HAL_PLUG = 12
};
bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = HAL_OBJECT_INVALID;
const ObjectType ObjectType_MAX = HAL_PLUG;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum msgidType {
  MSGID_MAX = 4000,
  MSGID_ROUTE_DELIMITER = 4001,
  MSGID_ERROR_MSG = 4002,
  MSGID_BLOB = 4003,
  MSGID_STRING = 4004,
  MSGID_HOP = 4005
};
bool msgidType_IsValid(int value);
const msgidType msgidType_MIN = MSGID_MAX;
const msgidType msgidType_MAX = MSGID_HOP;
const int msgidType_ARRAYSIZE = msgidType_MAX + 1;

const ::google::protobuf::EnumDescriptor* msgidType_descriptor();
inline const ::std::string& msgidType_Name(msgidType value) {
  return ::google::protobuf::internal::NameOfEnum(
    msgidType_descriptor(), value);
}
inline bool msgidType_Parse(
    const ::std::string& name, msgidType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<msgidType>(
    msgidType_descriptor(), name, value);
}
enum socketType {
  ST_ZMQ_PAIR = 0,
  ST_ZMQ_PUB = 1,
  ST_ZMQ_SUB = 2,
  ST_ZMQ_REQ = 3,
  ST_ZMQ_REP = 4,
  ST_ZMQ_DEALER = 5,
  ST_ZMQ_ROUTER = 6,
  ST_ZMQ_PULL = 7,
  ST_ZMQ_PUSH = 8,
  ST_ZMQ_XPUB = 9,
  ST_ZMQ_XSUB = 10,
  ST_ZMQ_STREAM = 11,
  ST_ZMQ_INVALID = 15
};
bool socketType_IsValid(int value);
const socketType socketType_MIN = ST_ZMQ_PAIR;
const socketType socketType_MAX = ST_ZMQ_INVALID;
const int socketType_ARRAYSIZE = socketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* socketType_descriptor();
inline const ::std::string& socketType_Name(socketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    socketType_descriptor(), value);
}
inline bool socketType_Parse(
    const ::std::string& name, socketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<socketType>(
    socketType_descriptor(), name, value);
}
enum securityMechanism {
  SM_ZMQ_NONE = -1,
  SM_ZMQ_NULL = 0,
  SM_ZMQ_PLAIN = 1,
  SM_ZMQ_CURVE = 2
};
bool securityMechanism_IsValid(int value);
const securityMechanism securityMechanism_MIN = SM_ZMQ_NONE;
const securityMechanism securityMechanism_MAX = SM_ZMQ_CURVE;
const int securityMechanism_ARRAYSIZE = securityMechanism_MAX + 1;

const ::google::protobuf::EnumDescriptor* securityMechanism_descriptor();
inline const ::std::string& securityMechanism_Name(securityMechanism value) {
  return ::google::protobuf::internal::NameOfEnum(
    securityMechanism_descriptor(), value);
}
inline bool securityMechanism_Parse(
    const ::std::string& name, securityMechanism* value) {
  return ::google::protobuf::internal::ParseNamedEnum<securityMechanism>(
    securityMechanism_descriptor(), name, value);
}
enum RCS_STATUS {
  UNINITIALIZED_STATUS = -1,
  RCS_DONE = 1,
  RCS_EXEC = 2,
  RCS_ERROR = 3,
  RCS_RECEIVED = 4
};
bool RCS_STATUS_IsValid(int value);
const RCS_STATUS RCS_STATUS_MIN = UNINITIALIZED_STATUS;
const RCS_STATUS RCS_STATUS_MAX = RCS_RECEIVED;
const int RCS_STATUS_ARRAYSIZE = RCS_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* RCS_STATUS_descriptor();
inline const ::std::string& RCS_STATUS_Name(RCS_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    RCS_STATUS_descriptor(), value);
}
inline bool RCS_STATUS_Parse(
    const ::std::string& name, RCS_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RCS_STATUS>(
    RCS_STATUS_descriptor(), name, value);
}
enum MsgOrigin {
  MSG_KERNEL = 0,
  MSG_RTUSER = 1,
  MSG_ULAPI = 2
};
bool MsgOrigin_IsValid(int value);
const MsgOrigin MsgOrigin_MIN = MSG_KERNEL;
const MsgOrigin MsgOrigin_MAX = MSG_ULAPI;
const int MsgOrigin_ARRAYSIZE = MsgOrigin_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgOrigin_descriptor();
inline const ::std::string& MsgOrigin_Name(MsgOrigin value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgOrigin_descriptor(), value);
}
inline bool MsgOrigin_Parse(
    const ::std::string& name, MsgOrigin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgOrigin>(
    MsgOrigin_descriptor(), name, value);
}
enum MsgLevel {
  RTAPI_MSG_NONE = 0,
  RTAPI_MSG_ERR = 1,
  RTAPI_MSG_WARN = 2,
  RTAPI_MSG_INFO = 3,
  RTAPI_MSG_DBG = 4,
  RTAPI_MSG_ALL = 5
};
bool MsgLevel_IsValid(int value);
const MsgLevel MsgLevel_MIN = RTAPI_MSG_NONE;
const MsgLevel MsgLevel_MAX = RTAPI_MSG_ALL;
const int MsgLevel_ARRAYSIZE = MsgLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgLevel_descriptor();
inline const ::std::string& MsgLevel_Name(MsgLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgLevel_descriptor(), value);
}
inline bool MsgLevel_Parse(
    const ::std::string& name, MsgLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLevel>(
    MsgLevel_descriptor(), name, value);
}
enum OriginDetail {
  UNIX_SIGNAL = 10,
  INSTANCE_SHUTDOWN = 20,
  ZMQ_SOCKET = 70,
  NML_LAYER = 80,
  RCS_LAYER = 90,
  CMS_LAYER = 100,
  IP_LAYER = 110,
  TCP_LAYER = 120,
  PGM_LAYER = 130
};
bool OriginDetail_IsValid(int value);
const OriginDetail OriginDetail_MIN = UNIX_SIGNAL;
const OriginDetail OriginDetail_MAX = PGM_LAYER;
const int OriginDetail_ARRAYSIZE = OriginDetail_MAX + 1;

const ::google::protobuf::EnumDescriptor* OriginDetail_descriptor();
inline const ::std::string& OriginDetail_Name(OriginDetail value) {
  return ::google::protobuf::internal::NameOfEnum(
    OriginDetail_descriptor(), value);
}
inline bool OriginDetail_Parse(
    const ::std::string& name, OriginDetail* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OriginDetail>(
    OriginDetail_descriptor(), name, value);
}
enum OriginType {
  PROCESS = 10,
  USER_THREAD = 20,
  RT_THREAD = 30,
  COMPONENT = 40,
  THREAD_FUNCTION = 50,
  COMPONENT_INIT = 60,
  COMPONENT_EXIT = 70,
  GROUP = 80,
  PIN = 90,
  SIGNAL = 100
};
bool OriginType_IsValid(int value);
const OriginType OriginType_MIN = PROCESS;
const OriginType OriginType_MAX = SIGNAL;
const int OriginType_ARRAYSIZE = OriginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OriginType_descriptor();
inline const ::std::string& OriginType_Name(OriginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OriginType_descriptor(), value);
}
inline bool OriginType_Parse(
    const ::std::string& name, OriginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OriginType>(
    OriginType_descriptor(), name, value);
}
enum Severity {
  S_INFORMATIONAL = 1,
  S_WARNING = 2,
  S_FAIL = 4
};
bool Severity_IsValid(int value);
const Severity Severity_MIN = S_INFORMATIONAL;
const Severity Severity_MAX = S_FAIL;
const int Severity_ARRAYSIZE = Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Severity_descriptor();
inline const ::std::string& Severity_Name(Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Severity_descriptor(), value);
}
inline bool Severity_Parse(
    const ::std::string& name, Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Severity>(
    Severity_descriptor(), name, value);
}
enum StatusType {
  ENQUEUED = 1,
  PROCESSING = 2,
  COMPLETE = 3,
  FAILED = 4
};
bool StatusType_IsValid(int value);
const StatusType StatusType_MIN = ENQUEUED;
const StatusType StatusType_MAX = FAILED;
const int StatusType_ARRAYSIZE = StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusType_descriptor();
inline const ::std::string& StatusType_Name(StatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusType_descriptor(), value);
}
inline bool StatusType_Parse(
    const ::std::string& name, StatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusType>(
    StatusType_descriptor(), name, value);
}
enum ReplyType {
  NONE = 0,
  ON_RECEPTION = 1,
  ON_QUEUED = 2,
  ON_COMPLETION = 4,
  ALL_STEPS = 255
};
bool ReplyType_IsValid(int value);
const ReplyType ReplyType_MIN = NONE;
const ReplyType ReplyType_MAX = ALL_STEPS;
const int ReplyType_ARRAYSIZE = ReplyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReplyType_descriptor();
inline const ::std::string& ReplyType_Name(ReplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReplyType_descriptor(), value);
}
inline bool ReplyType_Parse(
    const ::std::string& name, ReplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReplyType>(
    ReplyType_descriptor(), name, value);
}
enum ServiceType {
  ST_LOGGING = 1,
  ST_CONFIG = 2,
  ST_REDIS = 3,
  ST_HTTP = 4,
  ST_HTTPS = 5,
  ST_WEBSOCKET = 6,
  ST_WEBSOCKETS = 7,
  ST_RTAPI_COMMAND = 8,
  ST_STP_HALGROUP = 9,
  ST_STP_HALRCOMP = 10,
  ST_STP_INTERP = 11,
  ST_STP_TASK = 12,
  ST_HAL_RCOMMAND = 13,
  ST_TASK_COMMAND = 14,
  ST_INTERP_COMMAND = 15,
  ST_MESSAGEBUS_COMMAND = 16,
  ST_MESSAGEBUS_RESPONSE = 17
};
bool ServiceType_IsValid(int value);
const ServiceType ServiceType_MIN = ST_LOGGING;
const ServiceType ServiceType_MAX = ST_MESSAGEBUS_RESPONSE;
const int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceType_descriptor();
inline const ::std::string& ServiceType_Name(ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceType_descriptor(), value);
}
inline bool ServiceType_Parse(
    const ::std::string& name, ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
enum ServiceAPI {
  SA_ZMQ_PROTOBUF = 1,
  SA_WS_JSON = 2
};
bool ServiceAPI_IsValid(int value);
const ServiceAPI ServiceAPI_MIN = SA_ZMQ_PROTOBUF;
const ServiceAPI ServiceAPI_MAX = SA_WS_JSON;
const int ServiceAPI_ARRAYSIZE = ServiceAPI_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceAPI_descriptor();
inline const ::std::string& ServiceAPI_Name(ServiceAPI value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceAPI_descriptor(), value);
}
inline bool ServiceAPI_Parse(
    const ::std::string& name, ServiceAPI* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceAPI>(
    ServiceAPI_descriptor(), name, value);
}
enum ContainerType {
  MT_RTMESSAGE = 2,
  MT_MOTCMD = 3,
  MT_MOTSTATUS = 4,
  MT_LEGACY_MOTCMD = 5,
  MT_LEGACY_MOTSTATUS = 6,
  MT_WOU = 7,
  MT_HALUPDATE = 8,
  MT_RTAPI_MESSAGE = 9,
  MT_LOG_MESSAGE = 10,
  MT_PREVIEW = 11,
  MT_PROGRESS = 12,
  MT_INTERP_STAT = 13,
  MT_SYSLOG = 18,
  MT_LEGACY_NML = 19,
  MT_LEGACY_MOTCONFIG = 20,
  MT_STP_UPDATE_FULL = 26,
  MT_STP_UPDATE = 28,
  MT_STP_NOGROUP = 27,
  MT_SHUTDOWN = 45,
  MT_CONFIRM_SHUTDOWN = 50,
  MT_RTMESSAGE0 = 30,
  MT_RTMESSAGE1 = 31,
  MT_RTMESSAGE2 = 32,
  MT_RTMESSAGE3 = 33,
  MT_RTMESSAGE4 = 34,
  MT_ASCII = 100,
  MT_UNICODE = 101,
  MT_GCODE = 102,
  MT_PYTHON = 103,
  MT_PICKLE = 104,
  MT_TCL = 105,
  MT_XML = 106,
  MT_JSON = 107,
  MT_JPEG = 108,
  MT_PNG = 109,
  MT_TIFF = 110,
  MT_POSTSCRIPT = 111,
  MT_SVG = 112,
  MT_ZMQ_SUBSCRIBE = 150,
  MT_ZMQ_UNSUBSCRIBE = 151,
  MT_PING = 210,
  MT_PING_ACKNOWLEDGE = 215,
  MT_REJECT = 220,
  MT_DONE = 240,
  MT_SERVICE_REQUEST = 250,
  MT_SERVICE_ANNOUNCEMENT = 251,
  MT_SERVICE_PROBE = 252,
  MT_MESSAGEBUS_NO_DESTINATION = 255,
  MT_HALRCOMP_BIND = 256,
  MT_HALRCOMP_BIND_CONFIRM = 257,
  MT_HALRCOMP_BIND_REJECT = 258,
  MT_HALRCOMP_SET = 259,
  MT_HALRCOMP_SET_REJECT = 260,
  MT_HALRCOMP_ACK = 263,
  MT_HALRCOMMAND_SET = 265,
  MT_HALRCOMMAND_SET_REJECT = 266,
  MT_HALRCOMMAND_GET = 267,
  MT_HALRCOMMAND_GET_REJECT = 268,
  MT_HALRCOMMAND_CREATE = 269,
  MT_HALRCOMMAND_CREATE_REJECT = 270,
  MT_HALRCOMMAND_DELETE = 271,
  MT_HALRCOMMAND_DELETE_REJECT = 272,
  MT_HALRCOMMAND_ACK = 273,
  MT_HALRCOMMAND_ERROR = 274,
  MT_HALRCOMMAND_DESCRIBE = 276,
  MT_HALRCOMMAND_DESCRIPTION = 277,
  MT_HALRCOMP_FULL_UPDATE = 288,
  MT_HALRCOMP_INCREMENTAL_UPDATE = 289,
  MT_HALRCOMP_ERROR = 290,
  MT_HALGROUP_BIND = 294,
  MT_HALGROUP_BIND_CONFIRM = 295,
  MT_HALGROUP_BIND_REJECT = 296,
  MT_HALGROUP_FULL_UPDATE = 297,
  MT_HALGROUP_INCREMENTAL_UPDATE = 298,
  MT_HALGROUP_ERROR = 299,
  MT_RTAPI_APP_EXIT = 300,
  MT_RTAPI_APP_PING = 301,
  MT_RTAPI_APP_LOADRT = 302,
  MT_RTAPI_APP_LOG = 303,
  MT_RTAPI_APP_UNLOADRT = 305,
  MT_RTAPI_APP_NEWINST = 306,
  MT_RTAPI_APP_NEWTHREAD = 307,
  MT_RTAPI_APP_DELTHREAD = 308,
  MT_RTAPI_APP_CALLFUNC = 309,
  MT_RTAPI_APP_REPLY = 310,
  MT_RTAPI_APP_DELINST = 311,
  MT_LIST_APPLICATIONS = 350,
  MT_DESCRIBE_APPLICATION = 351,
  MT_RETRIEVE_APPLICATION = 352,
  MT_APPLICATION_DETAIL = 353,
  MT_ERROR = 360,
  MT_FULL_UPDATE = 370,
  MT_INCREMENTAL_UPDATE = 371,
  MT_TASK_REPLY = 400,
  MT_TICKET_UPDATE = 401,
  MT_CREDIT_UPDATE = 450,
  MT_EMCMOT_LOWER = 1000,
  MT_EMCMOT_UPPER = 1100,
  MT_EMCMOT_ABORT = 1001,
  MT_EMCMOT_AXIS_ABORT = 1002,
  MT_EMCMOT_ENABLE = 1003,
  MT_EMCMOT_DISABLE = 1004,
  MT_EMCMOT_ENABLE_AMPLIFIER = 1005,
  MT_EMCMOT_DISABLE_AMPLIFIER = 1006,
  MT_EMCMOT_ENABLE_WATCHDOG = 1007,
  MT_EMCMOT_DISABLE_WATCHDOG = 1008,
  MT_EMCMOT_ACTIVATE_JOINT = 1009,
  MT_EMCMOT_DEACTIVATE_JOINT = 1010,
  MT_EMCMOT_PAUSE = 1011,
  MT_EMCMOT_RESUME = 1012,
  MT_EMCMOT_STEP = 1013,
  MT_EMCMOT_FREE = 1014,
  MT_EMCMOT_COORD = 1015,
  MT_EMCMOT_TELEOP = 1016,
  MT_EMCMOT_SPINDLE_SCALE = 1017,
  MT_EMCMOT_SS_ENABLE = 1018,
  MT_EMCMOT_FEED_SCALE = 1019,
  MT_EMCMOT_FS_ENABLE = 1020,
  MT_EMCMOT_FH_ENABLE = 1021,
  MT_EMCMOT_AF_ENABLE = 1022,
  MT_EMCMOT_OVERRIDE_LIMITS = 1023,
  MT_EMCMOT_HOME = 1024,
  MT_EMCMOT_UNHOME = 1025,
  MT_EMCMOT_JOG_CONT = 1026,
  MT_EMCMOT_JOG_INCR = 1027,
  MT_EMCMOT_JOG_ABS = 1028,
  MT_EMCMOT_SET_LINE = 1029,
  MT_EMCMOT_SET_CIRCLE = 1030,
  MT_EMCMOT_SET_TELEOP_VECTOR = 1031,
  MT_EMCMOT_CLEAR_PROBE_FLAGS = 1032,
  MT_EMCMOT_PROBE = 1033,
  MT_EMCMOT_RIGID_TAP = 1034,
  MT_EMCMOT_SET_POSITION_LIMITS = 1035,
  MT_EMCMOT_SET_BACKLASH = 1036,
  MT_EMCMOT_SET_MIN_FERROR = 1037,
  MT_EMCMOT_SET_MAX_FERROR = 1038,
  MT_EMCMOT_SET_VEL = 1039,
  MT_EMCMOT_SET_VEL_LIMIT = 1040,
  MT_EMCMOT_SET_JOINT_VEL_LIMIT = 1041,
  MT_EMCMOT_SET_JOINT_ACC_LIMIT = 1042,
  MT_EMCMOT_SET_ACC = 1043,
  MT_EMCMOT_SET_TERM_COND = 1044,
  MT_EMCMOT_SET_NUM_AXES = 1045,
  MT_EMCMOT_SET_WORLD_HOME = 1046,
  MT_EMCMOT_SET_HOMING_PARAMS = 1047,
  MT_EMCMOT_SET_DEBUG = 1048,
  MT_EMCMOT_SET_DOUT = 1049,
  MT_EMCMOT_SET_AOUT = 1050,
  MT_EMCMOT_SET_SPINDLESYNC = 1051,
  MT_EMCMOT_SPINDLE_ON = 1052,
  MT_EMCMOT_SPINDLE_OFF = 1053,
  MT_EMCMOT_SPINDLE_INCREASE = 1054,
  MT_EMCMOT_SPINDLE_DECREASE = 1055,
  MT_EMCMOT_SPINDLE_BRAKE_ENGAGE = 1056,
  MT_EMCMOT_SPINDLE_BRAKE_RELEASE = 1057,
  MT_EMCMOT_SET_MOTOR_OFFSET = 1058,
  MT_EMCMOT_SET_JOINT_COMP = 1059,
  MT_EMCMOT_SET_OFFSET = 1060,
  MT_EMCMOT_COMMAND_OK = 1061,
  MT_EMCMOT_COMMAND_UNKNOWN_COMMAND = 1062,
  MT_EMCMOT_COMMAND_INVALID_COMMAND = 1063,
  MT_EMCMOT_COMMAND_INVALID_PARAMS = 1064,
  MT_EMCMOT_COMMAND_BAD_EXEC = 1065,
  MT_EMCMOT_MOTION_DISABLED = 1066,
  MT_EMCMOT_MOTION_FREE = 1067,
  MT_EMCMOT_MOTION_TELEOP = 1068,
  MT_EMCMOT_MOTION_COORD = 1069,
  MT_EMCMOT_JOINT_FLAG = 1070,
  MT_EMCMOT_MOTION_FLAG = 1071,
  MT_PRU_FIRMWARE = 2048,
  MT_MESA_5I20_FIRMWARE = 3000,
  MT_BLOB = 4000,
  MT_TEST1 = 5001,
  MT_TEST2 = 5002,
  MT_TEST3 = 5003,
  MT_EMC_NML_LOWER = 10000,
  MT_EMC_NML_UPPER = 13000,
  MT_EMC_OPERATOR_ERROR = 10011,
  MT_EMC_OPERATOR_TEXT = 10012,
  MT_EMC_OPERATOR_DISPLAY = 10013,
  MT_EMC_NULL = 10021,
  MT_EMC_SET_DEBUG = 10022,
  MT_EMC_SYSTEM_CMD = 10030,
  MT_EMC_AXIS_SET_AXIS = 10101,
  MT_EMC_AXIS_SET_UNITS = 10102,
  MT_EMC_AXIS_SET_MIN_POSITION_LIMIT = 10107,
  MT_EMC_AXIS_SET_MAX_POSITION_LIMIT = 10108,
  MT_EMC_TOOL_START_CHANGE = 1110,
  MT_EMC_EXEC_PLUGIN_CALL = 1112,
  MT_EMC_IO_PLUGIN_CALL = 1113,
  MT_EMC_AXIS_SET_FERROR = 10111,
  MT_EMC_AXIS_SET_HOMING_PARAMS = 10112,
  MT_EMC_AXIS_SET_MIN_FERROR = 10115,
  MT_EMC_AXIS_SET_MAX_VELOCITY = 10116,
  MT_EMC_AXIS_INIT = 10118,
  MT_EMC_AXIS_HALT = 10119,
  MT_EMC_AXIS_ABORT = 10120,
  MT_EMC_AXIS_ENABLE = 10121,
  MT_EMC_AXIS_DISABLE = 10122,
  MT_EMC_AXIS_HOME = 10123,
  MT_EMC_AXIS_UNHOME = 10135,
  MT_EMC_AXIS_JOG = 10124,
  MT_EMC_AXIS_INCR_JOG = 10125,
  MT_EMC_AXIS_ABS_JOG = 10126,
  MT_EMC_AXIS_ACTIVATE = 10127,
  MT_EMC_AXIS_DEACTIVATE = 10128,
  MT_EMC_AXIS_OVERRIDE_LIMITS = 10129,
  MT_EMC_AXIS_LOAD_COMP = 10131,
  MT_EMC_AXIS_SET_BACKLASH = 10134,
  MT_EMC_AXIS_STAT = 10199,
  MT_EMC_TRAJ_SET_AXES = 10201,
  MT_EMC_TRAJ_SET_UNITS = 10202,
  MT_EMC_TRAJ_SET_CYCLE_TIME = 10203,
  MT_EMC_TRAJ_SET_MODE = 10204,
  MT_EMC_TRAJ_SET_VELOCITY = 10205,
  MT_EMC_TRAJ_SET_ACCELERATION = 10206,
  MT_EMC_TRAJ_SET_MAX_VELOCITY = 10207,
  MT_EMC_TRAJ_SET_MAX_ACCELERATION = 10208,
  MT_EMC_TRAJ_SET_SCALE = 10209,
  MT_EMC_TRAJ_SET_MOTION_ID = 10210,
  MT_EMC_TRAJ_INIT = 10211,
  MT_EMC_TRAJ_HALT = 10212,
  MT_EMC_TRAJ_ENABLE = 10213,
  MT_EMC_TRAJ_DISABLE = 10214,
  MT_EMC_TRAJ_ABORT = 10215,
  MT_EMC_TRAJ_PAUSE = 10216,
  MT_EMC_TRAJ_STEP = 10217,
  MT_EMC_TRAJ_RESUME = 10218,
  MT_EMC_TRAJ_DELAY = 10219,
  MT_EMC_TRAJ_LINEAR_MOVE = 10220,
  MT_EMC_TRAJ_CIRCULAR_MOVE = 10221,
  MT_EMC_TRAJ_SET_TERM_COND = 10222,
  MT_EMC_TRAJ_SET_OFFSET = 10223,
  MT_EMC_TRAJ_SET_G5X = 10224,
  MT_EMC_TRAJ_SET_HOME = 10225,
  MT_EMC_TRAJ_SET_ROTATION = 10226,
  MT_EMC_TRAJ_SET_G92 = 10227,
  MT_EMC_TRAJ_CLEAR_PROBE_TRIPPED_FLAG = 10228,
  MT_EMC_TRAJ_PROBE = 10229,
  MT_EMC_TRAJ_SET_TELEOP_ENABLE = 10230,
  MT_EMC_TRAJ_SET_TELEOP_VECTOR = 10231,
  MT_EMC_TRAJ_SET_SPINDLESYNC = 10232,
  MT_EMC_TRAJ_SET_SPINDLE_SCALE = 10233,
  MT_EMC_TRAJ_SET_FO_ENABLE = 10234,
  MT_EMC_TRAJ_SET_SO_ENABLE = 10235,
  MT_EMC_TRAJ_SET_FH_ENABLE = 10236,
  MT_EMC_TRAJ_RIGID_TAP = 10237,
  MT_EMC_TRAJ_SET_RAPID_SCALE = 10238,
  MT_EMC_TRAJ_STAT = 10299,
  MT_EMC_MOTION_INIT = 10301,
  MT_EMC_MOTION_HALT = 10302,
  MT_EMC_MOTION_ABORT = 10303,
  MT_EMC_MOTION_SET_AOUT = 10304,
  MT_EMC_MOTION_SET_DOUT = 10305,
  MT_EMC_MOTION_ADAPTIVE = 10306,
  MT_EMC_SPINDLE_ORIENT = 10317,
  MT_EMC_SPINDLE_WAIT_ORIENT_COMPLETE = 10318,
  MT_EMC_MOTION_STAT = 10399,
  MT_EMC_TASK_INIT = 10501,
  MT_EMC_TASK_HALT = 10502,
  MT_EMC_TASK_ABORT = 10503,
  MT_EMC_TASK_SET_MODE = 10504,
  MT_EMC_TASK_SET_STATE = 10505,
  MT_EMC_TASK_PLAN_OPEN = 10506,
  MT_EMC_TASK_PLAN_RUN = 10507,
  MT_EMC_TASK_PLAN_READ = 10508,
  MT_EMC_TASK_PLAN_EXECUTE = 10509,
  MT_EMC_TASK_PLAN_PAUSE = 10510,
  MT_EMC_TASK_PLAN_STEP = 10511,
  MT_EMC_TASK_PLAN_RESUME = 10512,
  MT_EMC_TASK_PLAN_END = 10513,
  MT_EMC_TASK_PLAN_CLOSE = 10514,
  MT_EMC_TASK_PLAN_INIT = 10515,
  MT_EMC_TASK_PLAN_SYNCH = 10516,
  MT_EMC_TASK_PLAN_SET_OPTIONAL_STOP = 10517,
  MT_EMC_TASK_PLAN_SET_BLOCK_DELETE = 10518,
  MT_EMC_TASK_PLAN_OPTIONAL_STOP = 10519,
  MT_EMC_TASK_PLAN_RESET = 10520,
  MT_EMC_TASK_PLAN_REPLY = 10530,
  MT_EMC_TASK_STAT = 10599,
  MT_EMC_TOOL_INIT = 11101,
  MT_EMC_TOOL_HALT = 11102,
  MT_EMC_TOOL_ABORT = 11103,
  MT_EMC_TOOL_PREPARE = 11104,
  MT_EMC_TOOL_LOAD = 11105,
  MT_EMC_TOOL_UNLOAD = 11106,
  MT_EMC_TOOL_LOAD_TOOL_TABLE = 11107,
  MT_EMC_TOOL_SET_OFFSET = 11108,
  MT_EMC_TOOL_SET_NUMBER = 11109,
  MT_EMC_TOOL_UPDATE_TOOL_TABLE = 11110,
  MT_EMC_TOOL_STAT = 11199,
  MT_EMC_AUX_ESTOP_ON = 11206,
  MT_EMC_AUX_ESTOP_OFF = 11207,
  MT_EMC_AUX_ESTOP_RESET = 11208,
  MT_EMC_AUX_INPUT_WAIT = 11209,
  MT_EMC_AUX_STAT = 11299,
  MT_EMC_SPINDLE_ON = 11304,
  MT_EMC_SPINDLE_OFF = 11305,
  MT_EMC_SPINDLE_INCREASE = 11309,
  MT_EMC_SPINDLE_DECREASE = 11310,
  MT_EMC_SPINDLE_CONSTANT = 11311,
  MT_EMC_SPINDLE_BRAKE_RELEASE = 11312,
  MT_EMC_SPINDLE_BRAKE_ENGAGE = 11313,
  MT_EMC_SPINDLE_SPEED = 11316,
  MT_EMC_SPINDLE_STAT = 11399,
  MT_EMC_COOLANT_MIST_ON = 11404,
  MT_EMC_COOLANT_MIST_OFF = 11405,
  MT_EMC_COOLANT_FLOOD_ON = 11406,
  MT_EMC_COOLANT_FLOOD_OFF = 11407,
  MT_EMC_COOLANT_STAT = 11499,
  MT_EMC_LUBE_ON = 11504,
  MT_EMC_LUBE_OFF = 11505,
  MT_EMC_LUBE_STAT = 11599,
  MT_EMC_IO_INIT = 11601,
  MT_EMC_IO_HALT = 11602,
  MT_EMC_IO_ABORT = 11603,
  MT_EMC_IO_SET_CYCLE_TIME = 11604,
  MT_EMC_IO_STAT = 11699,
  MT_EMC_INIT = 11901,
  MT_EMC_HALT = 11902,
  MT_EMC_ABORT = 11903,
  MT_EMC_STAT = 11999,
  MT_EMCSTAT_FULL_UPDATE = 12500,
  MT_EMCSTAT_INCREMENTAL_UPDATE = 12501,
  MT_EMC_NML_ERROR = 12510,
  MT_EMC_NML_TEXT = 12511,
  MT_EMC_NML_DISPLAY = 12512,
  MT_EMCCMD_EXECUTED = 12520,
  MT_EMCCMD_COMPLETED = 12521,
  MT_LAUNCHER_FULL_UPDATE = 12600,
  MT_LAUNCHER_INCREMENTAL_UPDATE = 12601,
  MT_LAUNCHER_ERROR = 12602,
  MT_LAUNCHER_START = 12610,
  MT_LAUNCHER_TERMINATE = 12611,
  MT_LAUNCHER_KILL = 12612,
  MT_LAUNCHER_WRITE_STDIN = 12613,
  MT_LAUNCHER_CALL = 12614,
  MT_LAUNCHER_SHUTDOWN = 12615
};
bool ContainerType_IsValid(int value);
const ContainerType ContainerType_MIN = MT_RTMESSAGE;
const ContainerType ContainerType_MAX = MT_EMC_NML_UPPER;
const int ContainerType_ARRAYSIZE = ContainerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContainerType_descriptor();
inline const ::std::string& ContainerType_Name(ContainerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContainerType_descriptor(), value);
}
inline bool ContainerType_Parse(
    const ::std::string& name, ContainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContainerType>(
    ContainerType_descriptor(), name, value);
}
enum OriginIndex {
  ORIGIN_UNKNOWN = 0,
  ORIGIN_G54 = 1,
  ORIGIN_G55 = 2,
  ORIGIN_G56 = 3,
  ORIGIN_G57 = 4,
  ORIGIN_G58 = 5,
  ORIGIN_G59 = 6,
  ORIGIN_G59_1 = 7,
  ORIGIN_G59_2 = 8,
  ORIGIN_G59_3 = 9
};
bool OriginIndex_IsValid(int value);
const OriginIndex OriginIndex_MIN = ORIGIN_UNKNOWN;
const OriginIndex OriginIndex_MAX = ORIGIN_G59_3;
const int OriginIndex_ARRAYSIZE = OriginIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* OriginIndex_descriptor();
inline const ::std::string& OriginIndex_Name(OriginIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    OriginIndex_descriptor(), value);
}
inline bool OriginIndex_Parse(
    const ::std::string& name, OriginIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OriginIndex>(
    OriginIndex_descriptor(), name, value);
}
enum TermConditionType {
  _EMC_TRAJ_TERM_COND_STOP = 1,
  _EMC_TRAJ_TERM_COND_BLEND = 2
};
bool TermConditionType_IsValid(int value);
const TermConditionType TermConditionType_MIN = _EMC_TRAJ_TERM_COND_STOP;
const TermConditionType TermConditionType_MAX = _EMC_TRAJ_TERM_COND_BLEND;
const int TermConditionType_ARRAYSIZE = TermConditionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TermConditionType_descriptor();
inline const ::std::string& TermConditionType_Name(TermConditionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TermConditionType_descriptor(), value);
}
inline bool TermConditionType_Parse(
    const ::std::string& name, TermConditionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TermConditionType>(
    TermConditionType_descriptor(), name, value);
}
enum CanonDirection {
  _CANON_STOPPED = 1,
  _CANON_CLOCKWISE = 2,
  _CANON_COUNTERCLOCKWISE = 3
};
bool CanonDirection_IsValid(int value);
const CanonDirection CanonDirection_MIN = _CANON_STOPPED;
const CanonDirection CanonDirection_MAX = _CANON_COUNTERCLOCKWISE;
const int CanonDirection_ARRAYSIZE = CanonDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* CanonDirection_descriptor();
inline const ::std::string& CanonDirection_Name(CanonDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    CanonDirection_descriptor(), value);
}
inline bool CanonDirection_Parse(
    const ::std::string& name, CanonDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CanonDirection>(
    CanonDirection_descriptor(), name, value);
}
enum InputType {
  _ANALOG_INPUT = 0,
  _DIGITAL_INPUT = 1
};
bool InputType_IsValid(int value);
const InputType InputType_MIN = _ANALOG_INPUT;
const InputType InputType_MAX = _DIGITAL_INPUT;
const int InputType_ARRAYSIZE = InputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InputType_descriptor();
inline const ::std::string& InputType_Name(InputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InputType_descriptor(), value);
}
inline bool InputType_Parse(
    const ::std::string& name, InputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputType>(
    InputType_descriptor(), name, value);
}
enum WaitType {
  IMMEDIATE = 0,
  RISE = 1,
  FALL = 2,
  BE_HIGH = 3,
  BE_LOW = 4
};
bool WaitType_IsValid(int value);
const WaitType WaitType_MIN = IMMEDIATE;
const WaitType WaitType_MAX = BE_LOW;
const int WaitType_ARRAYSIZE = WaitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WaitType_descriptor();
inline const ::std::string& WaitType_Name(WaitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WaitType_descriptor(), value);
}
inline bool WaitType_Parse(
    const ::std::string& name, WaitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WaitType>(
    WaitType_descriptor(), name, value);
}
enum InterpreterStateType {
  INTERP_IDLE = 1,
  INTERP_RUNNING = 2,
  INTERP_SYNC_WAIT = 3,
  INTERP_PAUSED = 4,
  INTERP_QUEUE_WAIT = 5,
  INTERP_ABORT_WAIT = 6,
  INTERP_STATE_UNSET = 99
};
bool InterpreterStateType_IsValid(int value);
const InterpreterStateType InterpreterStateType_MIN = INTERP_IDLE;
const InterpreterStateType InterpreterStateType_MAX = INTERP_STATE_UNSET;
const int InterpreterStateType_ARRAYSIZE = InterpreterStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InterpreterStateType_descriptor();
inline const ::std::string& InterpreterStateType_Name(InterpreterStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InterpreterStateType_descriptor(), value);
}
inline bool InterpreterStateType_Parse(
    const ::std::string& name, InterpreterStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterpreterStateType>(
    InterpreterStateType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace machinetalk

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::machinetalk::ValueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ValueType>() {
  return ::machinetalk::ValueType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::HalPinDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::HalPinDirection>() {
  return ::machinetalk::HalPinDirection_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::HalParamDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::HalParamDirection>() {
  return ::machinetalk::HalParamDirection_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::HalFunctType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::HalFunctType>() {
  return ::machinetalk::HalFunctType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::ObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ObjectType>() {
  return ::machinetalk::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::msgidType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::msgidType>() {
  return ::machinetalk::msgidType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::socketType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::socketType>() {
  return ::machinetalk::socketType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::securityMechanism> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::securityMechanism>() {
  return ::machinetalk::securityMechanism_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::RCS_STATUS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::RCS_STATUS>() {
  return ::machinetalk::RCS_STATUS_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::MsgOrigin> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::MsgOrigin>() {
  return ::machinetalk::MsgOrigin_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::MsgLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::MsgLevel>() {
  return ::machinetalk::MsgLevel_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::OriginDetail> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::OriginDetail>() {
  return ::machinetalk::OriginDetail_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::OriginType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::OriginType>() {
  return ::machinetalk::OriginType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::Severity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::Severity>() {
  return ::machinetalk::Severity_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::StatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::StatusType>() {
  return ::machinetalk::StatusType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::ReplyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ReplyType>() {
  return ::machinetalk::ReplyType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::ServiceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ServiceType>() {
  return ::machinetalk::ServiceType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::ServiceAPI> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ServiceAPI>() {
  return ::machinetalk::ServiceAPI_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::ContainerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::ContainerType>() {
  return ::machinetalk::ContainerType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::OriginIndex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::OriginIndex>() {
  return ::machinetalk::OriginIndex_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::TermConditionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::TermConditionType>() {
  return ::machinetalk::TermConditionType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::CanonDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::CanonDirection>() {
  return ::machinetalk::CanonDirection_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::InputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::InputType>() {
  return ::machinetalk::InputType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::WaitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::WaitType>() {
  return ::machinetalk::WaitType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::InterpreterStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::InterpreterStateType>() {
  return ::machinetalk::InterpreterStateType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_machinetalk_2fprotobuf_2ftypes_2eproto__INCLUDED
